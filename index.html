<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sword Spine: Structural Physics</title>
    <style>
        :root {
            --bg: #0f1215;
            --panel-bg: #1a1e24;
            --text-main: #aab2bd;
            --accent: #3498db;
            --danger: #e74c3c;
            --safe: #2ecc71;
            --grid-line: #2c3e50;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg);
            color: var(--text-main);
            font-family: 'Courier New', monospace;
            overflow: hidden;
            display: flex;
            height: 100vh;
        }

        canvas {
            display: block;
            flex-grow: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
        }

        #top-bar {
            height: 50px;
            background: rgba(15, 18, 21, 0.95);
            border-bottom: 2px solid var(--grid-line);
            display: flex;
            align-items: center;
            padding: 0 20px;
            pointer-events: auto;
            justify-content: space-between;
        }

        .mode-btn {
            background: var(--panel-bg);
            border: 1px solid var(--grid-line);
            color: var(--text-main);
            padding: 8px 16px;
            margin-left: 10px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            text-transform: uppercase;
        }

        .mode-btn.active {
            background: var(--accent);
            color: #fff;
        }

        #stats-panel {
            position: absolute;
            top: 60px;
            right: 20px;
            width: 280px;
            background: rgba(26, 30, 36, 0.9);
            border: 1px solid var(--grid-line);
            padding: 15px;
            pointer-events: auto;
            font-size: 11px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }

        .stat-val {
            color: var(--accent);
            font-weight: bold;
        }

        .stat-bad {
            color: var(--danger);
        }

        #forge-overlay {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(26, 30, 36, 0.95);
            border: 1px solid var(--grid-line);
            padding: 20px;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
            border-radius: 4px;
        }

        #forge-overlay.hidden {
            display: none;
        }

        .inventory-row {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .module-item {
            width: 60px;
            height: 60px;
            background: #2a3038;
            border: 1px solid #444;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: grab;
            font-size: 10px;
            text-align: center;
            user-select: none;
        }

        .module-item:active {
            cursor: grabbing;
        }

        .module-icon {
            width: 25px;
            height: 25px;
            margin-bottom: 4px;
        }

        .mod-iron .module-icon {
            background: #7f8c8d;
        }

        .mod-wood .module-icon {
            background: #d35400;
            border-radius: 2px;
        }

        /* Actually brown */
        .mod-gold .module-icon {
            background: #f1c40f;
            border-radius: 50%;
        }

        .mod-glass .module-icon {
            background: #aed6f1;
            transform: rotate(45deg);
            border: 1px solid #fff;
        }

        #combat-overlay {
            position: absolute;
            bottom: 20px;
            right: 20px;
            pointer-events: auto;
        }

        #combat-overlay.hidden {
            display: none;
        }
    </style>
</head>

<body>
    <div id="ui-layer">
        <div id="top-bar">
            <div style="font-size: 18px; color: var(--accent);">KINETIC FORGE <span
                    style="font-size:10px; color:#666;">// STRUCTURAL PHYSICS</span></div>
            <div>
                <button class="mode-btn active" onclick="setMode('FORGE')">Forge</button>
                <button class="mode-btn" onclick="setMode('COMBAT')">Combat Test</button>
            </div>
        </div>

        <div id="stats-panel">
            <div class="stat-row"><span>Total Mass:</span> <span id="s-mass" class="stat-val">0</span> kg</div>
            <div class="stat-row"><span>Length:</span> <span id="s-len" class="stat-val">0</span> m</div>
            <div class="stat-row"><span>Moment of Inertia (I):</span> <span id="s-moi" class="stat-val">0</span> kg·m²
            </div>
            <div style="margin:5px 0; border-bottom:1px solid #333;"></div>
            <div class="stat-row"><span>Logic:</span> <span class="stat-val" style="color:#aaa;">Torque > Integrity =
                    BREAK</span></div>
            <div class="stat-row"><span>Max Torque Applied:</span> <span id="s-torque" class="stat-val">0</span> Nm
            </div>
            <div class="stat-row"><span>Peak Stress:</span> <span id="s-stress" class="stat-val">0</span> Nm</div>
            <div id="s-warning" style="color:yellow; text-align:center; margin-top:5px; display:none;">STRUCTURAL
                WARNING</div>
        </div>

        <div id="forge-overlay">
            <div style="text-align:center; color:#888; font-size:10px;">MATERIALS</div>
            <div class="inventory-row" id="inv-container"></div>
            <div style="height:1px; background:#444; margin:5px 0;"></div>
            <div style="text-align:center; color:#888; font-size:10px;">SWORD ASSEMBLY (LEFT=HANDLE)</div>
            <div class="inventory-row" id="slot-container"></div>
        </div>

        <div id="combat-overlay" class="hidden">
            <!-- Combat specific overlay content -->
        </div>

        <!-- Persistent UI -->
        <div style="position: absolute; bottom: 20px; right: 20px; pointer-events: auto;">
            <button class="mode-btn" style="background:#e74c3c;" onclick="resetSim()">Reset Position</button>
        </div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        // --- CONSTANTS ---
        const CANVAS = document.getElementById('gameCanvas');
        const CTX = CANVAS.getContext('2d');

        // Physics Config
        const PX_PER_METER = 50.0; // 50 pixels = 1 meter
        const DT = 1 / 60;
        const MAX_TORQUE = 800; // Anime Super Strength
        const K_P = 2000; // Super Stiffness 
        const K_D = 25;  // Damping increased slightly for stability

        // Stability Config
        const ANGULAR_DAMPING = 0.90; // Global air resistance
        const STRUCTURAL_MULTIPLIER = 15.0; // Strengthen joints vs internal limits
        const SPAWN_GRACE_PERIOD = 1000; // ms

        // Physics Rules
        const PHYSICS_RULES = {
            enemyArmor: 25.0,
            recoilFactor: 1.0
        };

        // Materials
        const MATERIALS = {
            'wood': { name: 'Wood Beam', mass: 1.5, integrity: 250, sharpness: 0.8, color: '#8B4513', w: 10, h: 40, desc: 'Light, Weak' },
            'iron': { name: 'Heavy Iron', mass: 3.0, integrity: 2000, sharpness: 2.0, color: '#708090', w: 30, h: 30, desc: 'Balanced, Durable' },
            'gold': { name: 'Soft Gold', mass: 6.0, integrity: 400, sharpness: 1.0, color: '#FFD700', w: 35, h: 25, desc: 'Heavy, Soft' },
            'glass': { name: 'Obsidian Shard', mass: 0.6, integrity: 20, sharpness: 2.5, color: '#00FFFF', w: 20, h: 50, desc: 'Fragile, Sharp' }
        };

        // --- STATE ---
        let GAME_MODE = 'FORGE';
        let swordSlots = [MATERIALS['wood'], MATERIALS['wood'], MATERIALS['iron'], MATERIALS['gold'], MATERIALS['glass']]; // Default

        // Physics State
        let player = {
            x: 0, y: 0,
            angle: 0,
            velocity: 0,
            torque: 0,
            targetAngle: 0
        };

        let nodes = []; // The active physics nodes
        let debris = [];
        let enemies = [];
        let enemy = { x: 0, y: 0, w: 60, h: 100, hp: 500, maxHp: 500, hitFlash: 0 };

        let currentStats = { mass: 0, I: 0, peakStress: 0 };
        let simStartTime = 0; // For grace period

        // Input
        let mouse = { x: 0, y: 0 };
        let keys = { w: false, a: false, s: false, d: false };

        // --- INIT ---
        function init() {
            resize();
            window.addEventListener('resize', resize);
            window.addEventListener('mousemove', e => {
                mouse.x = e.clientX;
                mouse.y = e.clientY;
            });
            window.addEventListener('keydown', e => {
                if (e.key === 'w' || e.key === 'W') keys.w = true;
                if (e.key === 'a' || e.key === 'A') keys.a = true;
                if (e.key === 's' || e.key === 'S') keys.s = true;
                if (e.key === 'd' || e.key === 'D') keys.d = true;
            });
            window.addEventListener('keyup', e => {
                if (e.key === 'w' || e.key === 'W') keys.w = false;
                if (e.key === 'a' || e.key === 'A') keys.a = false;
                if (e.key === 's' || e.key === 'S') keys.s = false;
                if (e.key === 'd' || e.key === 'D') keys.d = false;
            });

            // UI Setup
            setupUI();
            rebuildSword();
            resetSim();

            requestAnimationFrame(loop);
        }

        function resize() {
            CANVAS.width = window.innerWidth;
            CANVAS.height = window.innerHeight;
            // Default position, can be moved
            if (!player.x) {
                player.x = CANVAS.width * 0.4;
                player.y = CANVAS.height * 0.6;
            }
            // Move enemy closer
            enemy.x = CANVAS.width * 0.65;
            enemy.y = CANVAS.height * 0.6;
        }

        function setupUI() {
            const inv = document.getElementById('inv-container');
            const slots = document.getElementById('slot-container');

            // Create Tooltip
            let tooltip = document.getElementById('game-tooltip');
            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.id = 'game-tooltip';
                tooltip.style.cssText = 'position:absolute; background:rgba(20,20,20,0.95); border:1px solid #555; padding:8px; font-size:11px; color:#eee; pointer-events:none; display:none; z-index:9999; white-space:nowrap; border-radius:4px; box-shadow:0 2px 10px rgba(0,0,0,0.5);';
                document.body.appendChild(tooltip);
            }

            const showTip = (e, mat) => {
                tooltip.style.display = 'block';
                tooltip.innerHTML = `<strong style="color:${mat.color}; font-size:12px;">${mat.name}</strong><br>
                                    <span style="color:#aaa">Mass:</span> ${mat.mass} kg<br>
                                    <span style="color:#aaa">Integrity:</span> ${mat.integrity}<br>
                                    <span style="color:#aaa">Sharpness:</span> ${mat.sharpness}<br>
                                    <em style="color:#888; margin-top:4px; display:block;">${mat.desc}</em>`;
                moveTip(e);
            };
            const moveTip = (e) => {
                tooltip.style.left = (e.clientX + 15) + 'px';
                tooltip.style.top = (e.clientY + 15) + 'px';
            };
            const hideTip = () => tooltip.style.display = 'none';

            // Inventory
            inv.innerHTML = ''; // Clear prev
            Object.keys(MATERIALS).forEach(k => {
                const mat = MATERIALS[k];
                const el = document.createElement('div');
                el.className = `module-item mod-${k}`;
                el.draggable = true;
                el.innerHTML = `<div class="module-icon"></div><div>${mat.name.split(' ')[0]}</div>`;
                el.ondragstart = (e) => e.dataTransfer.setData('mat', k);

                el.onmouseenter = (e) => showTip(e, mat);
                el.onmousemove = moveTip;
                el.onmouseleave = hideTip;

                inv.appendChild(el);
            });

            // Slots
            slots.innerHTML = ''; // Clear prev
            for (let i = 0; i < 5; i++) {
                const el = document.createElement('div');
                el.className = 'module-item';
                el.style.borderStyle = 'dashed';
                el.dataset.idx = i;
                el.ondragover = (e) => e.preventDefault();
                el.ondrop = (e) => {
                    e.preventDefault();
                    const key = e.dataTransfer.getData('mat');
                    swordSlots[i] = MATERIALS[key];
                    renderSlots();
                    rebuildSword();
                    // Refire enter to show tooltip for new item immediately
                    if (MATERIALS[key]) showTip(e, MATERIALS[key]);
                };
                el.onclick = () => {
                    swordSlots[i] = null;
                    renderSlots();
                    rebuildSword();
                    hideTip();
                };

                el.onmousemove = (e) => {
                    if (swordSlots[i]) {
                        if (tooltip.style.display === 'none') showTip(e, swordSlots[i]);
                        moveTip(e);
                    } else {
                        hideTip();
                    }
                };
                el.onmouseleave = hideTip;

                slots.appendChild(el);
            }
            renderSlots();
        }

        function renderSlots() {
            const slots = document.getElementById('slot-container').children;
            for (let i = 0; i < 5; i++) {
                const mat = swordSlots[i];
                const el = slots[i];
                // Reset classes
                el.className = 'module-item';
                if (mat) {
                    const key = Object.keys(MATERIALS).find(k => MATERIALS[k] === mat);
                    el.classList.add(`mod-${key}`);
                    el.style.borderStyle = 'solid';
                    el.innerHTML = `<div class="module-icon"></div><div>${mat.name.split(' ')[0]}</div>`;
                } else {
                    el.style.borderStyle = 'dashed';
                    el.innerHTML = '<span style="color:#444">Empty</span>';
                }
            }
        }

        function setMode(m) {
            GAME_MODE = m;
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`button[onclick="setMode('${m}')"]`).classList.add('active');

            document.getElementById('forge-overlay').classList.toggle('hidden', m !== 'FORGE');
            document.getElementById('combat-overlay').classList.toggle('hidden', m !== 'COMBAT');

            if (m === 'COMBAT') resetSim();
        }

        function resetSim() {
            player.angle = 0;
            player.velocity = 0;
            player.targetAngle = 0;
            rebuildSword();
            enemy.hp = enemy.maxHp;
            debris = [];
            simStartTime = Date.now();
            // Reset position if needed, but keeping WASD position is better for flow
        }

        function rebuildSword() {
            nodes = [];
            let r_pixels = 40; // Start offset

            swordSlots.forEach(mat => {
                if (!mat) return;

                // Visual size
                const w = mat.w;
                const h = mat.h;
                // Center of this node
                const centerR = r_pixels + h / 2;

                nodes.push({
                    mat: mat,
                    r: centerR / PX_PER_METER, // Store in METERS
                    r_px: centerR,
                    w: w, h: h,
                    stressRatio: 0
                });

                r_pixels += h; // Stack vertically
            });

            currentStats.len = r_pixels / PX_PER_METER;
        }

        // --- PHYSICS LOOP ---
        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        function update() {
            // WASD Movement
            const moveSpeed = 5;
            if (keys.w) player.y -= moveSpeed;
            if (keys.s) player.y += moveSpeed;
            if (keys.a) player.x -= moveSpeed;
            if (keys.d) player.x += moveSpeed;

            if (nodes.length === 0) return;

            // 1. Calculate Target Angle
            const dx = mouse.x - player.x;
            const dy = mouse.y - player.y;
            player.targetAngle = Math.atan2(dy, dx);

            // Wrap angle
            let diff = player.targetAngle - player.angle;
            while (diff > Math.PI) diff -= Math.PI * 2;
            while (diff < -Math.PI) diff += Math.PI * 2;

            // 2. Calculate Moment of Inertia (I) - LINEAR SCALING (Anime Physics)
            let I = 0.1; // Base arm inertia
            let totalMass = 0;
            nodes.forEach(n => {
                // CHEAT: Use Linear Distance instead of Squared Distance
                // This makes long weapons feel much lighter and snappier
                I += n.mat.mass * n.r;
                totalMass += n.mat.mass;
            });
            currentStats.I = I;
            currentStats.mass = totalMass;

            // 3. PD Controller (Torque)
            let torque = (K_P * diff) - (K_D * player.velocity);

            // Clamp Torque (Human Limit)
            if (torque > MAX_TORQUE) torque = MAX_TORQUE;
            if (torque < -MAX_TORQUE) torque = -MAX_TORQUE;
            player.torque = torque;

            // 4. Integration
            const alpha = torque / I;
            player.velocity += alpha * DT;
            player.angle += player.velocity * DT;
            player.velocity *= ANGULAR_DAMPING; // Friction

            // 5. STRUCTURAL INTEGRITY (Bending Moment)
            // We calculate the load on each joint.
            // Joint i is "before" Node i.

            // We iterate backwards from tip to accumulate load.
            // The Load Moment at Joint i = Sum of (Force_k * Distance_from_joint_i) for all k >= i

            let accumulatedMoment = 0;
            let accumulatedForceT = 0; // Tangential Force Accumulator

            let breakIndex = -1;
            let peakStress = 0;

            for (let i = nodes.length - 1; i >= 0; i--) {
                const node = nodes[i];

                // Tangential Force: Mass * Tangential Accel (alpha * r)
                const Ft = node.mat.mass * Math.abs(alpha) * node.r;

                // Centrifugal Force: Mass * Radial Accel (w^2 * r)
                // This pulls the joint apart; strictly tensile, but contributes to failure.
                // We'll treat it as a smaller component of the generic "Stress"
                const Fc = node.mat.mass * (player.velocity * player.velocity) * node.r;

                // Simple Beam Theory approximation for gameplay:
                // Stress = Bending Moment due to inertia + Tensile Stress due to centrifugal

                // Moment load added by THIS node on PREVIOUS joints
                // But for THIS joint (at i), the moment is the sum of all outer forces * their distance from i

                // Let's do a direct summation for clarity (O(N^2) but N=5 so fine)
                // Calculate Moment at Joint i (start of Node i)
                const jointR = node.r - (node.h / 2 / PX_PER_METER); // Position of the joint

                let momentAtJoint = 0;
                for (let k = i; k < nodes.length; k++) {
                    const outerNode = nodes[k];
                    const distArm = outerNode.r - jointR;

                    const F_tangential = outerNode.mat.mass * Math.abs(alpha) * outerNode.r;
                    const F_centrifugal = outerNode.mat.mass * (player.velocity * player.velocity) * outerNode.r;

                    // Moment = Tangential Force * Arm
                    // We add a fraction of Centrifugal to represent general unstable vibration/tension
                    momentAtJoint += (F_tangential * distArm) + (F_centrifugal * distArm * 0.2);
                }

                node.stress = momentAtJoint;
                const maxIntegrity = node.mat.integrity * STRUCTURAL_MULTIPLIER;
                node.stressRatio = momentAtJoint / maxIntegrity; // Update visual ratio

                if (momentAtJoint > peakStress) peakStress = momentAtJoint;

                const isGracePeriod = (Date.now() - simStartTime) < SPAWN_GRACE_PERIOD;
                if (!isGracePeriod && momentAtJoint > maxIntegrity && breakIndex === -1) {
                    breakIndex = i;
                }
            }
            currentStats.peakStress = peakStress;

            // Handle Breakage
            if (breakIndex !== -1) {
                // Break!
                const broken = nodes.splice(breakIndex); // Removes from i to end

                broken.forEach(bNode => {
                    // Convert to world space debris
                    const wx = player.x + Math.cos(player.angle) * bNode.r_px;
                    const wy = player.y + Math.sin(player.angle) * bNode.r_px;

                    const vx = -Math.sin(player.angle) * player.velocity * bNode.r_px;
                    const vy = Math.cos(player.angle) * player.velocity * bNode.r_px;

                    debris.push({
                        x: wx, y: wy,
                        vx: vx * DT + (Math.random() - 0.5) * 5, // Keep velocity scale
                        vy: vy * DT + (Math.random() - 0.5) * 5,
                        angle: player.angle,
                        vAngle: (Math.random() - 0.5) * 10,
                        mat: bNode.mat,
                        life: 100
                    });
                });

                // Screen Shake
                canvasShake = 10;
            }

            updateDebris();
            checkCollisions();
        }

        // --- COLLISION ---
        function checkCollisions() {
            if (enemy.hp <= 0) return;

            // Simple "Swept" collision to prevent tunneling
            // We check if the arc traced by the node intersects the enemy box

            const prevAngle = player.angle - (player.velocity * DT);

            nodes.forEach(node => {
                // We check 5 points along the arc from prevAngle to current angle
                const steps = 5;
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const theta = prevAngle + (player.angle - prevAngle) * t;

                    const wx = player.x + Math.cos(theta) * node.r_px;
                    const wy = player.y + Math.sin(theta) * node.r_px;

                    // AABB Check
                    // Expand enemy box slightly for "Generous" hit detection
                    const hitMargin = 10;
                    if (wx > enemy.x - enemy.w / 2 - hitMargin &&
                        wx < enemy.x + enemy.w / 2 + hitMargin &&
                        wy > enemy.y - enemy.h / 2 - hitMargin &&
                        wy < enemy.y + enemy.h / 2 + hitMargin) {

                        applyDamage(node);
                        return; // Hit processed for this node
                    }
                }
            });
        }

        function applyDamage(node) {
            if (enemy.hitFlash > 0) return; // Debounce

            const v = Math.abs(player.velocity * node.r); // Impact velocity
            const ke = 0.5 * node.mat.mass * v * v;
            const dmg = ke * node.mat.sharpness * 0.05; // Tuned scale

            if (dmg > 2) {
                enemy.hp -= dmg;
                enemy.hitFlash = 10; // Frames of invuln/flash

                // Floating Text
                const el = document.createElement('div');
                el.innerText = Math.floor(dmg);
                el.style.cssText = `position:absolute; left:${enemy.x}px; top:${enemy.y - 50}px; color:#fff; font-weight:bold; font-size:20px; pointer-events:none; transition:all 1s; z-index:99;`;
                document.body.appendChild(el);
                setTimeout(() => {
                    el.style.transform = 'translateY(-50px) scale(1.5)';
                    el.style.opacity = 0;
                }, 50);
                setTimeout(() => el.remove(), 1000);

                // Impulse Response (slow sword)
                player.velocity *= 0.6;
                // Visual
                if (dmg > 50) canvasShake = 5;
            }
        }

        function updateDebris() {
            debris.forEach(d => {
                d.x += d.vx;
                d.y += d.vy;
                d.angle += d.vAngle * DT;
                d.life--;
            });
            debris = debris.filter(d => d.life > 0);
        }

        // --- DRAW ---
        let canvasShake = 0;

        function draw() {
            // Reset Transform
            CTX.setTransform(1, 0, 0, 1, 0, 0);
            CTX.fillStyle = '#0f1215';
            CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);

            // Shake
            if (canvasShake > 0) {
                const dx = (Math.random() - 0.5) * canvasShake;
                const dy = (Math.random() - 0.5) * canvasShake;
                CTX.translate(dx, dy);
                canvasShake *= 0.9;
                if (canvasShake < 0.5) canvasShake = 0;
            }

            // Grid
            CTX.strokeStyle = '#1a1e24';
            CTX.beginPath();
            for (let i = 0; i < CANVAS.width; i += 50) { CTX.moveTo(i, 0); CTX.lineTo(i, CANVAS.height); }
            for (let i = 0; i < CANVAS.height; i += 50) { CTX.moveTo(0, i); CTX.lineTo(CANVAS.width, i); }
            CTX.stroke();

            // Stats Update
            document.getElementById('s-mass').innerText = currentStats.mass.toFixed(1);
            document.getElementById('s-len').innerText = (currentStats.len || 0).toFixed(2);
            document.getElementById('s-moi').innerText = currentStats.I.toFixed(2);
            document.getElementById('s-torque').innerText = Math.abs(player.torque).toFixed(0);
            document.getElementById('s-stress').innerText = Math.floor(currentStats.peakStress);

            // Player/Pivot
            CTX.fillStyle = '#3498db';
            CTX.beginPath(); CTX.arc(player.x, player.y, 8, 0, Math.PI * 2); CTX.fill();

            // Ghost Cursor
            CTX.strokeStyle = 'rgba(52, 152, 219, 0.3)';
            CTX.lineWidth = 1;
            CTX.setLineDash([5, 5]);
            CTX.beginPath(); CTX.moveTo(player.x, player.y);
            CTX.lineTo(player.x + Math.cos(player.targetAngle) * 300, player.y + Math.sin(player.targetAngle) * 300);
            CTX.stroke();
            CTX.setLineDash([]);

            // Sword
            nodes.forEach((node, i) => {
                const x = player.x + Math.cos(player.angle) * node.r_px;
                const y = player.y + Math.sin(player.angle) * node.r_px;

                // Draw Connection Line (Stress visual)
                const prevR = i === 0 ? 0 : nodes[i - 1].r_px;
                const px = player.x + Math.cos(player.angle) * prevR;
                const py = player.y + Math.sin(player.angle) * prevR;

                // Color based on Stress Ratio
                const ratio = Math.min(node.stressRatio, 1.0);
                const r = Math.floor(ratio * 255);
                const g = Math.floor((1 - ratio) * 200 + 55);
                CTX.strokeStyle = `rgb(${r},${g},0)`;
                CTX.lineWidth = 4;

                CTX.beginPath(); CTX.moveTo(px, py); CTX.lineTo(x, y); CTX.stroke();

                // Draw Node
                CTX.save();
                CTX.translate(x, y);
                CTX.rotate(player.angle);
                CTX.fillStyle = node.mat.color;
                CTX.fillRect(-node.w / 2, -node.h / 2, node.w, node.h);

                // Flash red on high stress
                if (ratio > 0.8 && Math.random() > 0.5) {
                    CTX.fillStyle = 'rgba(255,0,0,0.5)';
                    CTX.fillRect(-node.w / 2, -node.h / 2, node.w, node.h);
                }
                CTX.restore();
            });

            // Debris
            debris.forEach(d => {
                CTX.save();
                CTX.translate(d.x, d.y);
                CTX.rotate(d.angle);
                CTX.fillStyle = d.mat.color;
                CTX.globalAlpha = d.life / 100;
                CTX.fillRect(-d.mat.w / 2, -d.mat.h / 2, d.mat.w, d.mat.h);
                CTX.restore();
            });
            CTX.globalAlpha = 1;

            // Enemy
            if (enemy.hp > 0) {
                CTX.fillStyle = enemy.hitFlash > 0 ? '#fff' : '#c0392b';
                if (enemy.hitFlash > 0) enemy.hitFlash--;
                CTX.fillRect(enemy.x - enemy.w / 2, enemy.y - enemy.h / 2, enemy.w, enemy.h);

                // HP Bar
                CTX.fillStyle = '#444';
                CTX.fillRect(enemy.x - enemy.w / 2, enemy.y - enemy.h / 2 - 10, enemy.w, 5);
                CTX.fillStyle = '#2ecc71';
                CTX.fillRect(enemy.x - enemy.w / 2, enemy.y - enemy.h / 2 - 10, enemy.w * (enemy.hp / enemy.maxHp), 5);

                // Armor Label (Design Doc Requirement)
                CTX.fillStyle = '#ccc';
                CTX.font = '10px sans-serif';
                CTX.textAlign = 'center';
                CTX.fillText(`ARMOR: ${PHYSICS_RULES.enemyArmor}`, enemy.x, enemy.y + enemy.h / 2 + 15);
            }

            // Structural Warning Logic
            const warningEl = document.getElementById('s-warning');
            // If any node is stressed > 80% (0.8 ratio), show warning
            if (currentStats.peakStress > 0 && nodes.some(n => n.stressRatio > 0.8)) {
                warningEl.style.display = 'block';
                warningEl.innerText = "HIGH STRESS WARNING";
            } else {
                warningEl.style.display = 'none';
            }
        }

        // Start
        init();

    </script>
</body>

</html>