<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sword Spine: Structural Physics</title>
    <style>
        :root {
            --bg: #0f1215;
            --panel-bg: #1a1e24;
            --text-main: #aab2bd;
            --accent: #3498db;
            --danger: #e74c3c;
            --safe: #2ecc71;
            --grid-line: #2c3e50;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg);
            color: var(--text-main);
            font-family: 'Courier New', monospace;
            overflow: hidden;
            display: flex;
            height: 100vh;
        }

        canvas {
            display: block;
            flex-grow: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
        }

        #top-bar {
            height: 50px;
            background: rgba(15, 18, 21, 0.95);
            border-bottom: 2px solid var(--grid-line);
            display: flex;
            align-items: center;
            padding: 0 20px;
            pointer-events: auto;
            justify-content: space-between;
        }

        .mode-btn {
            background: var(--panel-bg);
            border: 1px solid var(--grid-line);
            color: var(--text-main);
            padding: 8px 16px;
            margin-left: 10px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            text-transform: uppercase;
        }

        .mode-btn.active {
            background: var(--accent);
            color: #fff;
        }

        #stats-panel {
            position: absolute;
            top: 60px;
            right: 20px;
            width: 280px;
            background: rgba(26, 30, 36, 0.9);
            border: 1px solid var(--grid-line);
            padding: 15px;
            pointer-events: auto;
            font-size: 11px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }

        .stat-val {
            color: var(--accent);
            font-weight: bold;
        }

        .stat-bad {
            color: var(--danger);
        }

        #forge-overlay {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(26, 30, 36, 0.95);
            border: 1px solid var(--grid-line);
            padding: 20px;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
            border-radius: 4px;
        }

        #forge-overlay.hidden {
            display: none;
        }

        .inventory-row {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .module-item {
            width: 60px;
            height: 60px;
            background: #2a3038;
            border: 1px solid #444;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: grab;
            font-size: 10px;
            text-align: center;
            user-select: none;
        }

        .module-item:active {
            cursor: grabbing;
        }

        .module-icon {
            width: 25px;
            height: 25px;
            margin-bottom: 4px;
        }

        .mod-iron .module-icon {
            background: #7f8c8d;
        }

        .mod-wood .module-icon {
            background: #d35400;
            border-radius: 2px;
        }

        /* Actually brown */
        .mod-gold .module-icon {
            background: #f1c40f;
            border-radius: 50%;
        }

        .mod-glass .module-icon {
            background: #aed6f1;
            transform: rotate(45deg);
            border: 1px solid #fff;
        }

        #combat-overlay {
            position: absolute;
            bottom: 20px;
            right: 20px;
            pointer-events: auto;
        }

        #combat-overlay.hidden {
            display: none;
        }
    </style>
</head>

<body>
    <div id="ui-layer">
        <div id="top-bar">
            <div style="font-size: 18px; color: var(--accent);">动力铸造 <span style="font-size:10px; color:#666;">//
                    结构物理</span></div>
            <div id="level-display"
                style="font-size: 14px; color: #fff; font-weight: bold; border: 1px solid #444; padding: 4px 10px; background: #222;">
                关卡 1 / 5</div>
            <div style="width:100px;"></div> <!-- Spacer -->
        </div>

        <div id="stats-panel">
            <div class="stat-row"><span>总质量:</span> <span id="s-mass" class="stat-val">0</span> kg</div>
            <div class="stat-row"><span>长度:</span> <span id="s-len" class="stat-val">0</span> m</div>
            <div class="stat-row"><span>转动惯量 (I):</span> <span id="s-moi" class="stat-val">0</span> kg·m²
            </div>
            <div style="margin:5px 0; border-bottom:1px solid #333;"></div>
            <div class="stat-row"><span>物理逻辑:</span> <span class="stat-val" style="color:#aaa;">扭矩 > 结构强度 =
                    断裂</span></div>
            <div class="stat-row"><span>最大力量:</span> <span id="s-strength" class="stat-val">0</span> Nm</div>
            <div class="stat-row"><span>当前扭矩:</span> <span id="s-torque" class="stat-val">0</span> Nm
            </div>
            <div class="stat-row"><span>结构应力:</span> <span id="s-stress" class="stat-val">0</span> Nm</div>
            <div class="stat-row"><span>秒伤 (DPS):</span> <span id="s-dps" class="stat-val"
                    style="color:#e67e22">0</span></div>
            <div id="s-warning" style="color:yellow; text-align:center; margin-top:5px; display:none;">结构强度
                警告</div>
        </div>

        <div id="forge-overlay">
            <div style="text-align:center; color:#888; font-size:10px;">材料库</div>
            <div class="inventory-row" id="inv-container"></div>
            <div style="height:1px; background:#444; margin:5px 0;"></div>
            <div style="text-align:center; color:#888; font-size:10px;">剑身组装 (左侧=剑柄)</div>
            <div class="inventory-row" id="slot-container"></div>

            <div style="margin-top: 15px; text-align: center; display:flex; justify-content:center; gap:10px;">
                <button class="mode-btn"
                    style="background:#e67e22; font-size:16px; padding:10px 30px; border:1px solid #d35400;"
                    onclick="setMode('COMBAT')">开始战斗</button>

                <button class="mode-btn"
                    style="background:#555; font-size:16px; padding:10px 20px; border:1px solid #777;"
                    onclick="resetSim()">重置</button>
            </div>
        </div>

        <div id="combat-overlay" class="hidden">
            <!-- Combat specific overlay content -->
        </div>

        <!-- Persistent UI Removed -->
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        // --- CONSTANTS ---
        const CANVAS = document.getElementById('gameCanvas');
        const CTX = CANVAS.getContext('2d');

        // Physics Config
        const PX_PER_METER = 50.0; // 50 pixels = 1 meter
        const DT = 1 / 60;
        const MAX_TORQUE = 500; // Anime Super Strength
        const K_P = 2000; // Super Stiffness 
        const K_D = 25;  // Damping increased slightly for stability

        // Stability Config
        const ANGULAR_DAMPING = 0.90; // Global air resistance
        const STRUCTURAL_MULTIPLIER = 15.0; // Strengthen joints vs internal limits
        const SPAWN_GRACE_PERIOD = 1000; // ms

        // Physics Rules
        const PHYSICS_RULES = {
            enemyArmor: 25.0,
            recoilFactor: 1.0
        };

        // Materials
        const MATERIALS = {
            'wood': { name: '木梁', mass: 1.5, integrity: 250, sharpness: 0.8, color: '#8B4513', w: 10, h: 40, desc: '轻便, 脆弱' },
            'iron': { name: '重铁', mass: 3.0, integrity: 600, sharpness: 1.2, color: '#708090', w: 30, h: 30, desc: '平衡, 耐用' },
            'gold': { name: '软金', mass: 6.0, integrity: 400, sharpness: 1.0, color: '#FFD700', w: 35, h: 25, desc: '沉重, 质软' },
            'glass': { name: '碎片', mass: 0.6, integrity: 50, sharpness: 3.5, color: '#00FFFF', w: 20, h: 50, desc: '易碎, 极锐' }
        };

        // --- STATE ---
        let GAME_MODE = 'FORGE';
        let swordSlots = [MATERIALS['wood'], null, null, null, null]; // Start with just a handle

        // Physics State
        let player = {
            x: 0, y: 0,
            angle: 0,
            velocity: 0,
            torque: 0,
            targetAngle: 0
        };

        let nodes = []; // The active physics nodes
        let debris = [];
        let enemies = [];
        let enemy = { x: 0, y: 0, w: 60, h: 100, hp: 500, maxHp: 500, hitFlash: 0 };

        let currentStats = { mass: 0, I: 0, peakStress: 0 };
        let simStartTime = 0; // For grace period
        let dpsHistory = []; // DPS Tracking

        // Input
        let mouse = { x: 0, y: 0 };
        let keys = { w: false, a: false, s: false, d: false };

        // --- INIT ---
        function init() {
            resize();
            window.addEventListener('resize', resize);

            // Mouse
            window.addEventListener('mousemove', e => {
                mouse.x = e.clientX;
                mouse.y = e.clientY;
            });

            // Touch (Aiming - Right Side of Screen)
            window.addEventListener('touchmove', e => {
                // Prevent default scrolling
                if (e.target === CANVAS) e.preventDefault();

                for (let i = 0; i < e.touches.length; i++) {
                    const t = e.touches[i];
                    // If touch is on right half, it's aiming
                    if (t.clientX > window.innerWidth / 2) {
                        mouse.x = t.clientX;
                        mouse.y = t.clientY;
                    }
                }
            }, { passive: false });

            // Keyboard
            window.addEventListener('keydown', e => {
                if (e.key === 'w' || e.key === 'W') keys.w = true;
                if (e.key === 'a' || e.key === 'A') keys.a = true;
                if (e.key === 's' || e.key === 'S') keys.s = true;
                if (e.key === 'd' || e.key === 'D') keys.d = true;
            });
            window.addEventListener('keyup', e => {
                if (e.key === 'w' || e.key === 'W') keys.w = false;
                if (e.key === 'a' || e.key === 'A') keys.a = false;
                if (e.key === 's' || e.key === 'S') keys.s = false;
                if (e.key === 'd' || e.key === 'D') keys.d = false;
            });

            // Joystick Setup
            setupJoystick();

            // UI Setup
            setupUI();
            rebuildSword();
            resetSim();

            requestAnimationFrame(loop);
        }

        // Joystick State
        let joystick = { active: false, x: 0, y: 0, originX: 0, originY: 0, dx: 0, dy: 0 };

        function setupJoystick() {
            // Touch Start: Check for left side touch
            window.addEventListener('touchstart', e => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if (t.clientX < window.innerWidth / 2) {
                        joystick.active = true;
                        joystick.id = t.identifier;
                        joystick.originX = t.clientX;
                        joystick.originY = t.clientY;
                        joystick.x = t.clientX;
                        joystick.y = t.clientY;
                        joystick.dx = 0;
                        joystick.dy = 0;
                    }
                }
            }, { passive: false });

            // Touch Move: Update Knob
            window.addEventListener('touchmove', e => {
                if (!joystick.active) return;
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if (t.identifier === joystick.id) {
                        joystick.x = t.clientX;
                        joystick.y = t.clientY;

                        // Limit radius
                        const maxR = 50;
                        let dx = joystick.x - joystick.originX;
                        let dy = joystick.y - joystick.originY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > maxR) {
                            const angle = Math.atan2(dy, dx);
                            dx = Math.cos(angle) * maxR;
                            dy = Math.sin(angle) * maxR;
                            joystick.x = joystick.originX + dx;
                            joystick.y = joystick.originY + dy;
                        }

                        // Normalized Input (-1 to 1)
                        joystick.dx = dx / maxR;
                        joystick.dy = dy / maxR;
                    }
                }
            }, { passive: false });

            // Touch End: Reset
            window.addEventListener('touchend', e => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === joystick.id) {
                        joystick.active = false;
                        joystick.dx = 0;
                        joystick.dy = 0;
                    }
                }
            });
        }

        function resize() {
            CANVAS.width = window.innerWidth;
            CANVAS.height = window.innerHeight;
            // Default position, can be moved
            if (!player.x) {
                player.x = CANVAS.width * 0.45;
                player.y = CANVAS.height * 0.5;
            }
            // Move enemy closer
            enemy.x = CANVAS.width * 0.45 + 50;
            enemy.y = CANVAS.height * 0.5;
        }

        // Enhanced Inventory Interaction (Click to Select)
        let selectedMaterial = null;

        function updateSelectionVisuals() {
            // Highlight selected inventory item
            const items = document.querySelectorAll('.module-item');
            items.forEach(el => {
                const name = el.innerText;
                if (selectedMaterial && name === selectedMaterial.name.split(' ')[0]) {
                    el.style.border = '2px solid #fff';
                    el.style.transform = 'scale(1.1)';
                } else {
                    el.style.border = '1px solid #555';
                    el.style.transform = 'scale(1)';
                }
            });

            // Highlight valid slots if something is selected
            const slots = document.querySelectorAll('.slot');
            slots.forEach((el, i) => {
                if (i < currentLevel) {
                    if (selectedMaterial) {
                        el.style.borderColor = '#2ecc71'; // Green hint
                    } else {
                        el.style.borderColor = '#444';
                    }
                }
            });
        }

        function setupUI() {
            const inv = document.getElementById('inv-container');
            const slots = document.getElementById('slot-container');

            // Create Tooltip
            let tooltip = document.getElementById('game-tooltip');
            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.id = 'game-tooltip';
                tooltip.style.cssText = 'position:absolute; background:rgba(20,20,20,0.95); border:1px solid #555; padding:8px; font-size:11px; color:#eee; pointer-events:none; display:none; z-index:9999; white-space:nowrap; border-radius:4px; box-shadow:0 2px 10px rgba(0,0,0,0.5);';
                document.body.appendChild(tooltip);
            }

            const showTip = (e, mat) => {
                tooltip.style.display = 'block';
                tooltip.innerHTML = `<strong style="color:${mat.color}; font-size:12px;">${mat.name}</strong><br>
                                    <span style="color:#aaa">质量:</span> ${mat.mass} kg<br>
                                    <span style="color:#aaa">强度:</span> ${mat.integrity}<br>
                                    <span style="color:#aaa">锋利:</span> ${mat.sharpness}<br>
                                    <em style="color:#888; margin-top:4px; display:block;">${mat.desc}</em>`;
                moveTip(e);
            };
            const moveTip = (e) => {
                tooltip.style.left = (e.clientX + 15) + 'px';
                tooltip.style.top = (e.clientY + 15) + 'px';
            };
            const hideTip = () => tooltip.style.display = 'none';

            // Inventory
            inv.innerHTML = ''; // Clear prev
            Object.keys(MATERIALS).forEach(k => {
                const mat = MATERIALS[k];
                const el = document.createElement('div');
                el.className = `module-item mod-${k}`;
                el.draggable = true;
                el.innerHTML = `<div class="module-icon"></div><div>${mat.name.split(' ')[0]}</div>`;
                el.ondragstart = (e) => e.dataTransfer.setData('mat', k);

                el.onmouseenter = (e) => showTip(e, mat);
                el.onmousemove = moveTip;
                el.onmouseleave = hideTip;

                inv.appendChild(el);
            });

            // Slots - Delegated to renderSlots()
            renderSlots();
        }


        let currentLevel = 1;
        const MAX_LEVELS = 5;

        function renderSlots() {
            const slotContainer = document.getElementById('slot-container');
            slotContainer.innerHTML = ''; // Clear and Re-render

            for (let i = 0; i < 5; i++) {
                const el = document.createElement('div');
                el.className = 'module-item';
                el.dataset.idx = i;
                const mat = swordSlots[i];

                // Base Styles
                el.style.borderStyle = 'solid';
                el.style.opacity = '1';
                el.style.pointerEvents = 'auto';

                // Click Handler (Place / Remove)
                el.onclick = () => {
                    if (i >= currentLevel) return;

                    if (selectedMaterial) {
                        // Place
                        swordSlots[i] = selectedMaterial;
                        selectedMaterial = null; // Consume selection
                        updateSelectionVisuals();
                        rebuildSword();
                        renderSlots();
                    } else if (swordSlots[i]) {
                        // Remove
                        swordSlots[i] = null;
                        rebuildSword();
                        renderSlots();
                    }
                };

                // Drag & Drop Handlers (Legacy)
                el.ondragover = (e) => {
                    e.preventDefault();
                    if (i < currentLevel) el.style.borderColor = '#fff';
                };
                el.ondragleave = (e) => {
                    if (i < currentLevel) el.style.borderColor = ''; // Let render fix it
                };
                el.ondrop = (e) => {
                    e.preventDefault();
                    if (i >= currentLevel) return;
                    const key = e.dataTransfer.getData('mat');
                    if (MATERIALS[key]) {
                        swordSlots[i] = MATERIALS[key];
                        rebuildSword();
                        renderSlots();
                    }
                };

                // State Rendering
                if (i >= currentLevel) {
                    // LOCKED SLOT
                    el.classList.add('locked');
                    el.style.opacity = '0.3';
                    el.style.pointerEvents = 'none';
                    el.style.borderStyle = 'dotted';
                    el.style.borderColor = '#555';
                    el.innerHTML = '<span style="color:#555; font-size:9px;">未解锁</span>';
                    if (swordSlots[i]) swordSlots[i] = null;
                } else if (mat) {
                    // FILLED SLOT
                    const key = Object.keys(MATERIALS).find(k => MATERIALS[k] === mat);
                    el.classList.add(`mod-${key}`);
                    el.innerHTML = `<div class="module-icon"></div><div>${mat.name.split(' ')[0]}</div>`;
                } else {
                    // EMPTY SLOT
                    el.style.borderStyle = 'dashed';
                    el.innerHTML = '<span style="color:#444">空</span>';

                    // Visual Hint for Selection
                    if (selectedMaterial) {
                        el.style.borderColor = '#2ecc71';
                        el.style.boxShadow = '0 0 5px #2ecc71';
                    }
                }

                // Append
                slotContainer.appendChild(el);
            }
        }

        let combatTimer = 0;
        const COMBAT_DURATION = 10; // Seconds

        function setMode(m) {
            GAME_MODE = m;

            // Show/Hide Overlays
            document.getElementById('forge-overlay').classList.toggle('hidden', m !== 'FORGE');
            document.getElementById('combat-overlay').classList.toggle('hidden', m !== 'COMBAT');

            if (m === 'COMBAT') {
                resetSim();
                // Reset Enemy HP for the fight
                enemy.hp = enemy.maxHp;
                combatTimer = COMBAT_DURATION;
            }
        }

        function resetSim() {
            player.angle = 0;
            player.velocity = 0;
            player.targetAngle = 0;
            rebuildSword();
            enemy.hp = enemy.maxHp;
            debris = [];
            simStartTime = Date.now();
            // Reset position if needed, but keeping WASD position is better for flow
        }

        function rebuildSword() {
            nodes = [];
            let r_pixels = 40; // Start offset

            swordSlots.forEach(mat => {
                if (!mat) return;

                // Visual size
                const w = mat.w;
                const h = mat.h;
                // Center of this node
                const centerR = r_pixels + h / 2;

                nodes.push({
                    mat: mat,
                    r: centerR / PX_PER_METER, // Store in METERS
                    r_px: centerR,
                    w: w, h: h,
                    stressRatio: 0
                });

                r_pixels += h; // Stack vertically
            });

            currentStats.len = r_pixels / PX_PER_METER;
        }

        // --- PHYSICS LOOP ---
        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        function update() {
            // Timer Logic
            if (GAME_MODE === 'COMBAT') {
                if (combatTimer > 0) {
                    combatTimer -= DT;
                    if (combatTimer <= 0) {
                        combatTimer = 0;
                        handleCombatFailure();
                    }
                }
            }

            // Movement (WASD + Joystick)
            const moveSpeed = 5;
            let moveDx = 0;
            let moveDy = 0;

            // Keyboard
            if (keys.w) moveDy -= 1;
            if (keys.s) moveDy += 1;
            if (keys.a) moveDx -= 1;
            if (keys.d) moveDx += 1;

            // Joystick (Override/Add)
            if (joystick.active) {
                moveDx += joystick.dx;
                moveDy += joystick.dy;
            }

            // Apply Movement
            player.x += moveDx * moveSpeed;
            player.y += moveDy * moveSpeed;

            // Screen Bounds check
            if (player.x < 0) player.x = 0;
            if (player.x > CANVAS.width) player.x = CANVAS.width;
            if (player.y < 0) player.y = 0;
            if (player.y > CANVAS.height) player.y = CANVAS.height;

            if (nodes.length === 0) return;

            // 1. Calculate Target Angle
            const dx = mouse.x - player.x;
            const dy = mouse.y - player.y;
            player.targetAngle = Math.atan2(dy, dx);

            // Wrap angle
            let diff = player.targetAngle - player.angle;
            while (diff > Math.PI) diff -= Math.PI * 2;
            while (diff < -Math.PI) diff += Math.PI * 2;

            // 2. Calculate Moment of Inertia (I) - LINEAR SCALING (Anime Physics)
            let I = 0.1; // Base arm inertia
            let totalMass = 0;
            nodes.forEach(n => {
                // CHEAT: Use Linear Distance instead of Squared Distance
                // This makes long weapons feel much lighter and snappier
                I += n.mat.mass * n.r;
                totalMass += n.mat.mass;
            });
            currentStats.I = I;
            currentStats.mass = totalMass;

            // 3. PD Controller (Torque)
            const strength = getPlayerStrength();
            const K_P_DYNAMIC = strength.kp;
            const MAX_TORQUE_DYNAMIC = strength.maxTorque;

            let torque = (K_P_DYNAMIC * diff) - (K_D * player.velocity);

            // Clamp Torque (Human Limit)
            if (torque > MAX_TORQUE_DYNAMIC) torque = MAX_TORQUE_DYNAMIC;
            if (torque < -MAX_TORQUE_DYNAMIC) torque = -MAX_TORQUE_DYNAMIC;
            player.torque = torque;

            // 4. Integration
            const alpha = torque / I;
            player.velocity += alpha * DT;
            player.angle += player.velocity * DT;
            player.velocity *= ANGULAR_DAMPING; // Friction

            // 5. STRUCTURAL INTEGRITY (Bending Moment)
            // We calculate the load on each joint.
            // Joint i is "before" Node i.

            // We iterate backwards from tip to accumulate load.
            // The Load Moment at Joint i = Sum of (Force_k * Distance_from_joint_i) for all k >= i

            let accumulatedMoment = 0;
            let accumulatedForceT = 0; // Tangential Force Accumulator

            let breakIndex = -1;
            let peakStress = 0;

            for (let i = nodes.length - 1; i >= 0; i--) {
                const node = nodes[i];

                // Tangential Force: Mass * Tangential Accel (alpha * r)
                const Ft = node.mat.mass * Math.abs(alpha) * node.r;

                // Centrifugal Force: Mass * Radial Accel (w^2 * r)
                // This pulls the joint apart; strictly tensile, but contributes to failure.
                // We'll treat it as a smaller component of the generic "Stress"
                const Fc = node.mat.mass * (player.velocity * player.velocity) * node.r;

                // Simple Beam Theory approximation for gameplay:
                // Stress = Bending Moment due to inertia + Tensile Stress due to centrifugal

                // Moment load added by THIS node on PREVIOUS joints
                // But for THIS joint (at i), the moment is the sum of all outer forces * their distance from i

                // Let's do a direct summation for clarity (O(N^2) but N=5 so fine)
                // Calculate Moment at Joint i (start of Node i)
                const jointR = node.r - (node.h / 2 / PX_PER_METER); // Position of the joint

                let momentAtJoint = 0;
                for (let k = i; k < nodes.length; k++) {
                    const outerNode = nodes[k];
                    const distArm = outerNode.r - jointR;

                    const F_tangential = outerNode.mat.mass * Math.abs(alpha) * outerNode.r;
                    const F_centrifugal = outerNode.mat.mass * (player.velocity * player.velocity) * outerNode.r;

                    // Moment = Tangential Force * Arm
                    // We add a fraction of Centrifugal to represent general unstable vibration/tension
                    momentAtJoint += (F_tangential * distArm) + (F_centrifugal * distArm * 0.2);
                }

                node.stress = momentAtJoint;
                const maxIntegrity = node.mat.integrity * STRUCTURAL_MULTIPLIER;
                node.stressRatio = momentAtJoint / maxIntegrity; // Update visual ratio

                if (momentAtJoint > peakStress) peakStress = momentAtJoint;

                const isGracePeriod = (Date.now() - simStartTime) < SPAWN_GRACE_PERIOD;
                if (!isGracePeriod && momentAtJoint > maxIntegrity && breakIndex === -1) {
                    breakIndex = i;
                }
            }
            currentStats.peakStress = peakStress;

            // Handle Breakage
            if (breakIndex !== -1) {
                // Break!
                const broken = nodes.splice(breakIndex); // Removes from i to end

                broken.forEach(bNode => {
                    // Convert to world space debris
                    const wx = player.x + Math.cos(player.angle) * bNode.r_px;
                    const wy = player.y + Math.sin(player.angle) * bNode.r_px;

                    const vx = -Math.sin(player.angle) * player.velocity * bNode.r_px;
                    const vy = Math.cos(player.angle) * player.velocity * bNode.r_px;

                    debris.push({
                        x: wx, y: wy,
                        vx: vx * DT + (Math.random() - 0.5) * 5, // Keep velocity scale
                        vy: vy * DT + (Math.random() - 0.5) * 5,
                        angle: player.angle,
                        vAngle: (Math.random() - 0.5) * 10,
                        mat: bNode.mat,
                        life: 100
                    });
                });

                // Screen Shake
                canvasShake = 10;
            }

            updateDebris();
            checkCollisions();
        }


        function updateDPS(dmg) {
            const now = Date.now();
            dpsHistory.push({ t: now, d: dmg });
        }

        function getDPS() {
            const now = Date.now();
            dpsHistory = dpsHistory.filter(e => now - e.t < 1000); // Clean up
            let total = 0;
            dpsHistory.forEach(e => total += e.d);
            return total;
        }

        // --- COLLISION ---
        function checkCollisions() {
            // In Forge mode, we always check collisions for DPS test.
            // In Combat mode, ONLY check if enemy is alive.
            if (GAME_MODE === 'COMBAT' && enemy.hp <= 0) return;

            // Simple "Swept" collision to prevent tunneling
            // We check if the arc traced by the node intersects the enemy box

            const prevAngle = player.angle - (player.velocity * DT);

            nodes.forEach(node => {
                // We check 5 points along the arc from prevAngle to current angle
                const steps = 5;
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const theta = prevAngle + (player.angle - prevAngle) * t;

                    const wx = player.x + Math.cos(theta) * node.r_px;
                    const wy = player.y + Math.sin(theta) * node.r_px;

                    // AABB Check
                    // Expand enemy box slightly for "Generous" hit detection
                    const hitMargin = 10;
                    if (wx > enemy.x - enemy.w / 2 - hitMargin &&
                        wx < enemy.x + enemy.w / 2 + hitMargin &&
                        wy > enemy.y - enemy.h / 2 - hitMargin &&
                        wy < enemy.y + enemy.h / 2 + hitMargin) {

                        applyDamage(node);
                        return; // Hit processed for this node
                    }
                }
            });
        }

        function applyDamage(node) {
            if (enemy.hitFlash > 0) return; // Debounce

            const v = Math.abs(player.velocity * node.r); // Impact velocity (Tangential)

            // BALANCE CHANGE: Use Momentum (mv) instead of Kinetic Energy (0.5mv^2)
            // This buffs heavy slow weapons and nerfs light fast weapons.
            const momentum = node.mat.mass * v;

            // Damage = Momentum * Sharpness * Scaling
            // Scaling reduced from 10.0 -> 3.5 (Final Balance) -> User requested 1.0 (Manual Edit)
            // PRESERVING USER EDIT: 1.0
            const dmg = momentum * node.mat.sharpness * 1.0;

            if (dmg > 2) {
                // ALWAYS show feedback & DPS
                updateDPS(dmg);
                const isForge = GAME_MODE === 'FORGE';

                if (!isForge) enemy.hp -= dmg;
                enemy.hitFlash = 10; // Frames of invuln/flash

                // Floating Text
                const el = document.createElement('div');
                el.innerText = Math.floor(dmg);
                el.style.cssText = `position:absolute; left:${enemy.x}px; top:${enemy.y - 50}px; color:${isForge ? '#aaa' : '#fff'}; font-weight:bold; font-size:20px; pointer-events:none; transition:all 1s; z-index:99;`;
                document.body.appendChild(el);
                setTimeout(() => {
                    el.style.transform = 'translateY(-50px) scale(1.5)';
                    el.style.opacity = 0;
                }, 50);
                setTimeout(() => el.remove(), 1000);

                // Impulse Response (slow sword)
                player.velocity *= 0.6;
                // Visual
                if (dmg > 50) canvasShake = 5;

                // CHECK VICTORY (Only in Combat)
                if (!isForge && enemy.hp <= 0) {
                    handleLevelComplete();
                }
            }
        }

        function handleLevelComplete() {
            if (currentLevel < MAX_LEVELS) {
                alert(`关卡 ${currentLevel} 完成！解锁第 ${currentLevel + 1} 个插槽...`);
                currentLevel++;
            } else {
                alert("即身成圣！剑神！(游戏循环重置)");
                currentLevel = 1;
            }

            // Update UI
            document.getElementById('level-display').innerText = `关卡 ${currentLevel} / ${MAX_LEVELS}`;

            // Unlock next slot logic is handled by renderSlots() which checks currentLevel
            renderSlots();

            // Reset Game for next level
            setMode('FORGE'); // Force back to forge to equip new slot

            // Scale Enemy
            enemy.maxHp = 500 + ((currentLevel - 1) * 800); // Scale difficulty
            enemy.hp = enemy.maxHp;

            // Reset sword position
            resetSim();
        }


        function updateDebris() {
            debris.forEach(d => {
                d.x += d.vx;
                d.y += d.vy;
                d.angle += d.vAngle * DT;
                d.life--;
            });
            debris = debris.filter(d => d.life > 0);
        }

        // --- DRAW ---
        let canvasShake = 0;

        // Level Scaling
        const BASE_TORQUE = 500;
        const BASE_KP = 2000;

        function getPlayerStrength() {
            // SCALING: Buff strength significantly per level to handle heavier weapons
            // Level 1: 800
            // Level 5: 800 + 4*600 = 3200 (4x Strength)
            return {
                maxTorque: BASE_TORQUE + (currentLevel - 1) * 800,
                kp: BASE_KP + (currentLevel - 1) * 800
            };
        }

        function handleCombatFailure() {
            alert("时间耗尽！任务失败。\n退回至关卡 1。");
            currentLevel = 1;

            // Explicitly clear high level slots
            for (let i = 1; i < 5; i++) swordSlots[i] = null;

            // Reset Enemy Scaling
            enemy.maxHp = 500 + (currentLevel * 1000);

            // Update UI
            document.getElementById('level-display').innerText = `关卡 ${currentLevel} / ${MAX_LEVELS}`;
            renderSlots();
            setMode('FORGE');
            resetSim(); // Rebuild sword physics
        }

        function draw() {
            // Reset Transform
            CTX.setTransform(1, 0, 0, 1, 0, 0);
            CTX.fillStyle = '#0f1215';
            CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);

            // Draw Timer (Background)
            if (GAME_MODE === 'COMBAT') {
                CTX.textAlign = 'center';
                CTX.font = 'bold 40px "Courier New"';
                CTX.fillStyle = combatTimer < 10 ? '#e74c3c' : '#34495e'; // Red if low time
                CTX.fillText(combatTimer.toFixed(1), CANVAS.width / 2, 80);
            }

            // Draw Joystick (If Active)
            if (joystick.active) {
                CTX.save();
                // Base
                CTX.beginPath();
                CTX.arc(joystick.originX, joystick.originY, 50, 0, Math.PI * 2);
                CTX.fillStyle = 'rgba(255, 255, 255, 0.1)';
                CTX.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                CTX.lineWidth = 2;
                CTX.fill();
                CTX.stroke();

                // Knob
                CTX.beginPath();
                CTX.arc(joystick.x, joystick.y, 20, 0, Math.PI * 2);
                CTX.fillStyle = 'rgba(52, 152, 219, 0.5)';
                CTX.fill();
                CTX.stroke();
                CTX.restore();
            }

            // Shake
            if (canvasShake > 0) {
                const dx = (Math.random() - 0.5) * canvasShake;
                const dy = (Math.random() - 0.5) * canvasShake;
                CTX.translate(dx, dy);
                canvasShake *= 0.9;
                if (canvasShake < 0.5) canvasShake = 0;
            }

            // Grid
            CTX.strokeStyle = '#1a1e24';
            CTX.beginPath();
            for (let i = 0; i < CANVAS.width; i += 50) { CTX.moveTo(i, 0); CTX.lineTo(i, CANVAS.height); }
            for (let i = 0; i < CANVAS.height; i += 50) { CTX.moveTo(0, i); CTX.lineTo(CANVAS.width, i); }
            CTX.stroke();

            // Stats Update
            document.getElementById('s-mass').innerText = currentStats.mass.toFixed(1);
            document.getElementById('s-len').innerText = (currentStats.len || 0).toFixed(2);
            document.getElementById('s-moi').innerText = currentStats.I.toFixed(2);
            document.getElementById('s-strength').innerText = getPlayerStrength().maxTorque;
            document.getElementById('s-torque').innerText = Math.abs(player.torque).toFixed(0);
            document.getElementById('s-stress').innerText = Math.floor(currentStats.peakStress);
            document.getElementById('s-dps').innerText = Math.floor(getDPS());

            // Player/Pivot (Character Visuals)

            // 1. Body (Static relative to Pivot)
            // Pivot is at player.x, player.y. This is the SHOULDER.
            // Body should be below it.

            CTX.save();
            CTX.translate(player.x, player.y);

            // Draw Body (Suit)
            CTX.fillStyle = '#2c3e50';
            CTX.fillRect(-15, -10, 30, 40); // Chest

            // Draw Head
            CTX.fillStyle = '#34495e';
            CTX.beginPath(); CTX.arc(0, -25, 12, 0, Math.PI * 2); CTX.fill(); // Head
            CTX.fillStyle = '#3498db'; // Visor
            CTX.fillRect(-8, -28, 16, 6);

            // Draw Arms (Holding the Pivot)
            CTX.strokeStyle = '#7f8c8d';
            CTX.lineWidth = 6;
            // Left Arm
            CTX.beginPath(); CTX.moveTo(-15, 0); CTX.lineTo(0, 0); CTX.stroke();
            // Right Arm
            CTX.beginPath(); CTX.moveTo(15, 0); CTX.lineTo(0, 0); CTX.stroke();

            CTX.restore();

            // The Pivot Point itself (Joint)
            CTX.fillStyle = '#e67e22'; // Interaction Point Color
            CTX.beginPath(); CTX.arc(player.x, player.y, 6, 0, Math.PI * 2); CTX.fill();

            // Ghost Cursor
            CTX.strokeStyle = 'rgba(230, 126, 34, 0.3)';
            CTX.lineWidth = 1;
            CTX.setLineDash([5, 5]);
            CTX.beginPath(); CTX.moveTo(player.x, player.y);
            CTX.lineTo(player.x + Math.cos(player.targetAngle) * 300, player.y + Math.sin(player.targetAngle) * 300);
            CTX.stroke();
            CTX.setLineDash([]);

            // Sword
            nodes.forEach((node, i) => {
                const x = player.x + Math.cos(player.angle) * node.r_px;
                const y = player.y + Math.sin(player.angle) * node.r_px;

                // Draw Connection Line (Stress visual)
                const prevR = i === 0 ? 0 : nodes[i - 1].r_px;
                const px = player.x + Math.cos(player.angle) * prevR;
                const py = player.y + Math.sin(player.angle) * prevR;

                // Color based on Stress Ratio
                const ratio = Math.min(node.stressRatio, 1.0);
                const r = Math.floor(ratio * 255);
                const g = Math.floor((1 - ratio) * 200 + 55);
                CTX.strokeStyle = `rgb(${r},${g},0)`;
                CTX.lineWidth = 4;

                CTX.beginPath(); CTX.moveTo(px, py); CTX.lineTo(x, y); CTX.stroke();

                // Draw Node
                CTX.save();
                CTX.translate(x, y);
                CTX.rotate(player.angle);
                CTX.fillStyle = node.mat.color;
                CTX.fillRect(-node.w / 2, -node.h / 2, node.w, node.h);

                // Flash red on high stress
                if (ratio > 0.8 && Math.random() > 0.5) {
                    CTX.fillStyle = 'rgba(255,0,0,0.5)';
                    CTX.fillRect(-node.w / 2, -node.h / 2, node.w, node.h);
                }
                CTX.restore();
            });

            // Debris
            debris.forEach(d => {
                CTX.save();
                CTX.translate(d.x, d.y);
                CTX.rotate(d.angle);
                CTX.fillStyle = d.mat.color;
                CTX.globalAlpha = d.life / 100;
                CTX.fillRect(-d.mat.w / 2, -d.mat.h / 2, d.mat.w, d.mat.h);
                CTX.restore();
            });
            CTX.globalAlpha = 1;

            // Enemy (Training Bot Visuals)
            if (enemy.hp > 0) {
                const isHit = enemy.hitFlash > 0;
                if (isHit) enemy.hitFlash--;

                CTX.save();
                CTX.translate(enemy.x, enemy.y);

                // Colors
                const bodyColor = isHit ? '#fff' : '#2c3e50'; // Dark Grey
                const armorColor = isHit ? '#fff' : '#c0392b'; // Red Armor
                const eyeColor = isHit ? '#fff' : '#e74c3c'; // Glowing Red Eye

                // 1. Legs (Simple stands)
                CTX.fillStyle = '#1a1a1a';
                CTX.fillRect(-20, 30, 10, 20); // Left Leg
                CTX.fillRect(10, 30, 10, 20);  // Right Leg

                // 2. Main Body (The Hitbox area mostly)
                CTX.fillStyle = bodyColor;
                CTX.fillRect(-enemy.w / 2, -enemy.h / 2, enemy.w, enemy.h);

                // 3. Armor Plates (Chest)
                CTX.fillStyle = armorColor;
                CTX.fillRect(-enemy.w / 2 + 5, -10, enemy.w - 10, 30); // Chest Plate

                // 4. Head
                CTX.fillStyle = bodyColor;
                CTX.beginPath();
                CTX.arc(0, -enemy.h / 2 - 15, 15, 0, Math.PI * 2);
                CTX.fill();

                // 5. Eye (Cyclops)
                CTX.fillStyle = eyeColor;
                CTX.shadowColor = eyeColor;
                CTX.shadowBlur = 10;
                CTX.beginPath();
                CTX.arc(0, -enemy.h / 2 - 15, 5, 0, Math.PI * 2);
                CTX.fill();
                CTX.shadowBlur = 0; // Reset glow

                CTX.restore();

                // HP Bar
                CTX.fillStyle = '#444';
                CTX.fillRect(enemy.x - enemy.w / 2, enemy.y - enemy.h / 2 - 15, enemy.w, 10);
                CTX.fillStyle = '#2ecc71';
                CTX.fillRect(enemy.x - enemy.w / 2, enemy.y - enemy.h / 2 - 15, enemy.w * (enemy.hp / enemy.maxHp), 10);

                // HP Text
                CTX.fillStyle = '#fff';
                CTX.font = 'bold 10px sans-serif';
                CTX.textAlign = 'center';
                CTX.fillText(`${Math.ceil(enemy.hp)} / ${enemy.maxHp}`, enemy.x, enemy.y - enemy.h / 2 - 6);

                // Armor Label (Design Doc Requirement)
                CTX.fillStyle = '#ccc';
                CTX.font = '10px sans-serif';
                CTX.textAlign = 'center';
                CTX.fillText(`ARMOR: ${PHYSICS_RULES.enemyArmor}`, enemy.x, enemy.y + enemy.h / 2 + 15);
            }

            // Structural Warning Logic
            const warningEl = document.getElementById('s-warning');
            // If any node is stressed > 80% (0.8 ratio), show warning
            if (currentStats.peakStress > 0 && nodes.some(n => n.stressRatio > 0.8)) {
                warningEl.style.display = 'block';
                warningEl.innerText = "HIGH STRESS WARNING";
            } else {
                warningEl.style.display = 'none';
            }
        }

        // Start
        init();

    </script>
</body>

</html>